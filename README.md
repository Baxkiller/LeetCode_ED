# LeetCode_ED
记录一下自己的刷题记录.
- 对于字符串的删除操作(2022/03/22)
  今天的每日一题中出现了对于字符串的处理,自己开始想着通过删除进行暴力更新,但是删除过程中存在问题,即自己料想的删除后的字符串与实际删除后的字符串相差较大.
  后来发现问题出在对于`erase`参数的认识不清:
  `erase`函数包括四个重载:
  - 给定一个迭代器:删除此迭代器指向的字符.
  - 给定两个迭代器:删除两个迭代器之间的字符,注意两个迭代器的关系为[)
  - 给定一个数字:数字代表字符串中字符的下标,删除字符下标及其之后的所有字符
  - 给定两个数字:前者代表字符串中字符的下标,后者代表要删除的字符的长度.


- 针对LeetCode的测试方式的猜想

  由于题解是以类的形式给出的,因此我们可以猜测是否是对每一个测试点都作为一个类对象,调用其中的对应函数进行求解.

  产生这样的猜想是根据T653,求解中将变量设置外**类外**的全局变量,结果发现每次都会卡在一个测试点,调试发现这个全局变量中的内容远大于测试点给定的内容,而当讲该全局变量更改为类内变量后,就没有出现这样的情况了.

- 关于`unordered_map`

  无序容器,和map容器一样的是通过键值对方式存储数据,存储的各个键值对的键互不相同且**不允许被修改**.不同的是`unorder_map`不会对数据进行排序:容器底层采用的是**哈希表存储结构**，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序.

  因为两者的底层实现的结构不同的原因,`map`以**红黑树**结构实现,每次操作的时间复杂度接近于$O(logn)$,而后者以**哈希表**实现,每次操作虽然存在冲突,但是大多数情况下其时间复杂度接近于$O(1)$.

  由此可以推断两者不同的适用场景:

  - `unorde_map`适用于要求查找速率快,且对单次查询性能要求不敏感的情况.
  - `map`适用于:
    - 元素需要有序
    - 对于单次查询时间较为敏感,必须保持查询性能的稳定性,比如实时应用等等.

  
